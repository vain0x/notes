# 式指向構文が言語処理系にもたらす複雑性

式の一部として条件分岐や反復、ローカル変数の導入などを許可している言語を **式指向の構文を持つ** と呼ぶことにする。

式指向の構文は書きやすくて便利な一方、言語の設計や実装に一定の複雑性を追加する。

## 式指向の構文の例

例えば Rust は式指向の構文を持ち、条件分岐を表す if はそれ自体が式になっている。分岐の結果として評価された節の結果が if 式の結果になる。

```rs
let x = if p() {
    f()
} else {
    g()
};
```

以降、サンプルコードは Rust 風の構文で書く。ただし型システムや処理系は Rust とは限らない。

## ジャンプとスタックマシンの相性の悪さ

式指向の構文を持つ場合、式の評価の途中でジャンプすることができる。

```rs
fn f() -> i32 {
    1 + { return 2; }
}
```

この関数をナイーブな実装のスタックマシン向けにコンパイルすると、次のような不正な振る舞いをする。

- 1 をスタックに積む
- 2 をスタックに積む
- return する。スタックから結果値 2 を pop して、関数から抜ける

ここで 1 はスタックに置かれたままであり、関数の実行の前後でスタックの深さが維持されない。

### 解決策

この問題を解決するには、レジスタマシンを使うか、ジャンプする際に不要になった値をスタックから pop するようなコードを生成すればいい。

## ジャンプする式の型

静的型システムを持つ式指向言語の場合、break/return などのジャンプ式にも静的な型をつける必要がある。

例えば次の関数に含まれる match 式は Some のアームが結果を持ち、None のアームは return する。
mach 式の結果は i32 でなければいけないので、return 式の結果は i32 か、それの部分型でなければいけない。

```ts
fn drain_sum(xs: &mut Vec<i32>) -> i32 {
    let mut total = 0;
    loop {
        let x = match xs.pop() {
            Some(it) => it,
            None => return total,
        };
        
        total += x;
    }
}
```

Rust の return 式には ! (never) 型がつく。! はあらゆる型の部分型なので、i32 の部分型でもある。
したがって match 式に i32 型をつけられる。

もう1つの方法として、return などのジャンプする式の出現ごとにフレッシュなメタ型 T を生成して `(return expr): T` とする方法がある。
単一化により型 T が他のアームの型になるので、型検査を通せる。
この方法だと部分型の仕組みを導入しなくて済む。
(こういった理由から ML の failwith 関数に `failwith<'a> : string -> 'a` という型がついている。)

いずれにせよ「never 型と部分型」や「メタ型変数と単一化」のような一定の仕組みの導入が要請される。

あるいは、妥協して、ジャンプする式には決め打ちで unit (あるいは (), void, null の) 型をつけるという案もある。
(この手法を採用している言語があるかは知らない。)
その場合、上記のような match 式は型検査を通らなくなり、式指向らしさの一部が失われる。
