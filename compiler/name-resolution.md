# 名前解決 (name resolution; nameres)

ソースコードに出現する名前 (識別子など) が、実際にどのシンボル (型・変数・関数など) を指しているかを明確にする処理。意味解析の一部。

## 用語集

(言語・コミュニティによって用語にゆらぎがある。)

- 識別子 (identifier; ident, id):
    名前を表すトークン。通常はアルファベット、数字、`_` からなる。キーワードは除く
- シンボル (symbol):
    名前によって指されるもの。変数や関数など
- シンボルテーブル (symbol table):
    名前とシンボルの対応表
- 修飾子 (qualifier):
    名前の参照元を明示する記号。`std::io` の `std::` の部分
- パス (path):
    `std::io::stdin` のように修飾子を含む名前 (Rust コンパイラでの用語)
- 非修飾名 (unqualified name):
    パスとは逆に、修飾子を含まない名前
- 完全修飾名 (fully-qualified name; FQN):
    名前空間のルートからシンボルへのパス。シンボルを完全に特定する。絶対パスのようなもの。
- シンボルの出現 (occurrence)
    - ソースコードに書かれた識別子やパスで、そのシンボルに解決されたもの
    - 例えば `fn f() { f() }` において `fn f` や `f()` などの `f` の部分が関数 f の出現
- 定義箇所 (definition site; def site):
    - シンボルの出現箇所で、そのシンボルの定義になっている部分 (何をもって定義になっているとするかは場合による。例えば Rust では `fn f() { ... }` は関数 f の定義箇所と考えられる)
- 使用箇所 (use site):
    - シンボルの出現箇所、そのシンボルを使っている部分
    - 定義箇所であると同時に使用箇所であることもありうる。例えば、いわゆるオブジェクトショートハンド (`let Point { x, y } = point;` の `x` など)

TODO:

- 名前空間 (namespace)
- 環境 (environment; env)
- スコープ (scope)

### 挙動の変種

### hoisting (巻き上げ)

宣言をブロックの先頭で環境に導入すること。

```rust
{
    // square はここで、このブロックの環境に導入される。
    // a はこの時点では導入されていない。

    let a = square(3); // a はここで導入される。

    fn square(x: i32) -> f64 {
        x * x
    }
}
```

- 何を hoisting するかは言語によるし、宣言の種類にもよる。
    - 変数宣言を hoisting すると未定義の変数が使えてしまって困りがち
    - 関数宣言を hoisting しないと相互再帰がしづらくなりがち
- 単一のブロックに hoisting される同じ名前のシンボルが複数あるときどうするかは言語による。

### shadowing (隠蔽)

環境にシンボルを導入するとき、同名のシンボルをその環境から追い出すこと。

```rust
// 単一のブロック内での shadowing
{
    let a = 1;
    println!("{}", a);  //=> 1

    let a = "2";
    println!("{}", a);  //=> 2
}
```

```rust
// 入れ子のブロックでの shadowing
{
    let a = 1;
    
    {
        let a = "2";
        println!("{}", a);  //=> 2
    }
    
    println!("{}", a);  //=> 1
}
```

- hoisting された宣言の shadowing をどうするかは言語による。Rust は hoisting された宣言も shadowing できる。

```rust
{
    // fn f はここでスコープに導入される
    
    f(); // この f は関数

    let f = 1; // fn f を shadowing する。

    fn f() {}

    let g = f; // この f は整数
}
```

- shadowing を認めず、名前の重複をエラーにするという戦略もありうる。
    - 同じパターンに含まれるシンボルを shadowing できたらカオス (`let (x, x) = (1, 2) in x //=> 2`!?)

## 処理手順

### 構文木を辿る方法

構文木上を DFS 順序で走査して、構文木に含まれるすべての名前を解決する手続き。

状態:

- 環境のスタック (`List[Map[String, Symbol]]`)
    - 値と型の環境を分けて持つ方がよいかもしれない。

処理:

- ルートやブロックに入ったとき:
    - 環境のスタックに空の `Map` を push する。
    - ブロックに直接含まれる、hoisting の対象となる宣言を列挙して、それが定義するシンボルを環境に導入する。
- 名前の定義箇所を見たとき:
    - hoisting の対象でなければ、環境に導入する。
- 名前の使用箇所を見たとき:
    - 非修飾名なら、環境のスタックの末尾から順に、この名前がマップに含まれるか調べて、含まれていたらそれが指すシンボルに解決する。
    - いずれにも含まれていなかったら未解決 (unresolved) とする。
- ブロックから出るとき:
    - 環境のスタックを pop する。
  
### 出現から逆順に辿る方法

(試したことはない。)

- 名前が含まれるブロックの前方にある宣言を逆順に見て、もっとも近くで導入される同じ名前のシンボルに解決する。
- 名前が含まれるブロックの後方にある、hoisting の対象となる宣言によって導入される同じ名前のシンボルに解決する。
- 解決できなければ、上のブロックを見て同じ処理を繰り返す。
- 最後まで解決されなければ未解決 (unresolved) とする。

### パースイベントを読む方法

パーサが関数宣言などの開始・終了時や、識別子の出現などの際にイベントを発行するとする。
前方参照の解決を一時的に遅延することで、これらのイベントを順番に処理する際に名前解決を行える。

この手法では、識別子やパスのうちローカルの環境に依存する部分だけ解決する。(ローカルの環境に依存しない部分、例えば `型名::メソッド名` のように型に依存するものなどは処理できないので、そのままの表現で持つ。)

let のように前方参照を許可しない宣言は普通に解決できる。ブロックに入る際に環境のスタックを伸ばし、出る際に戻せばよい。

前方参照の場合、名前が出現したタイミングでは解決できない。名前を解決できなかったとき、その名前とスコープIDをマップ (多重マップ) に入れておく。

前方参照を許すシンボルが環境に導入されたタイミングで、解決できなかった名前のマップを引く。名前が出現したスコープから、定義があるスコープが「みえる」なら、その名前をいま導入されたシンボルに解決する。

スコープが見えるための条件は、定義箇所のスコープが使用箇所のスコープの祖先になっていることである。(例えば `{ { f(); } fn f() {} }` なら `f()` から `fn f` が見える。`{ f(); } { fn f() {} }` だと見えない。)
スコープの親子関係は各スコープの親を記録しておけば分かる。
(使用箇所のスコープから親スコープを辿っていき、定義箇所のスコープに遭遇すれば OK. 通常、スコープの入れ子は浅いので線形探索で問題ないはず。効率化する方法はある？)

用意するもの:

- 現在のスコープID
- スコープIDから親スコープのIDへのマップ (あるいはベクタ)
- ローカルの環境
- 識別子から構文木への多重マップ (前方参照を記録するためのもの。)

行うこと:

- スコープに入るたび:
    - 環境のスタックを積む。
    - 新しいスコープIDを生成して現在のスコープIDとする。親スコープIDをマップに登録する。
- スコープから抜けるたび:
    - 環境のスタックを戻す (そのスコープに閉じている名前を環境から取り除く)。
    - 現在のスコープIDを親のスコープIDに変更する。
- シンボルを参照する構文がパースされたとき、その識別子、あるいはパスの先頭の名前 (ローカル環境に依存する部分) を、現在の環境で解決する。解決できなければ、その名前と現在のスコープIDをマップに入れる。(このタイミングで解決できないということは、前方参照だと思っててよい。)
- シンボルを定義する構文がパースされたとき、
    - hoisting されない (前方参照を許可しない) 場合: そのシンボルを環境に入れる。
    - hoisting される (前方参照を許可する) 場合: マップからその名前を探し、その名前が含まれていたスコープから現在のスコープが見えるなら、このシンボルに解決する。解決した名前はマップから取り除く。

## 名前解決が型や動的な状態に依存するケース

オブジェクト指向言語によくあるドット記法 `x.f()` は、`f` が何を指すかが `x` の型によるので、型検査・型推論の後でないと解決できない。

`eval` などにより動的にシンボルを環境に導入できる言語では、名前は実行時まで解決できない。

- [Dependent names - cppreference.com](https://en.cppreference.com/w/cpp/language/dependent_name) (C++ ではテンプレート引数が何に解決されるかによって解決結果が異なるパスを依存名と呼ぶ)

## 個々の構文の名前解決

### ローカル変数の宣言 (let)

式 init を評価して、それをパターン pat にマッチさせた後、パターンが定義するシンボルを環境に導入して next を評価する。

```rust
    // ML の構文

    let pat = init in next
    
    // Rust の構文

    let pat = init;
    next
```

記述順とは異なり、init → pat → next の順で処理する。

```rust
    // 疑似コード
    resolve_expr(init, &env);       // 式は環境を (一時的に拡張するかもしれないが、最終的には) 変化させない
    resolve_pat(pat, &mut env);     // パターンは環境を拡張する可能性がある
    resolve_expr(next, &env);
```

### ML (let-in)

ML 系の言語では let 式で値や関数を宣言できて、スコープが in 節の内部に閉じている。

```fsharp
let x = 1
in let y = 2
in x + y
```

これは (Rust のような言語では) let-in の連鎖を1個のブロック式とみなせる。

```rust
{
    let x = 1;
    let y = 2;
    x + y
}
```

### ML (let-and)

ML 系の言語には相互再帰のために宣言の間を and で繋ぐ構文がある。

```fsharp
let f () = ... // ここで f, g が使える
and g () = ... // ここで f, g が使える
in x
```

これは (Rust のような言語では) let-and-... の連鎖が1個のスコープに入っていて、そこで宣言されている各シンボルは hoisting されるとみなせる。

```rust
// 上と同様
{
    // f, g は hoisting されて、ここでスコープに導入される。

    fn f() {
        // ここで f, g が使える
    }

    fn g() {
        // ここで f, g が使える
    }

    x;
}
```

### 関数宣言

関数の宣言を hoisting しないとき、関数のシンボルを環境に導入するタイミングと、本体の名前解決を行うタイミングの順番に注意。関数を先に導入すると、本体でその関数の再帰呼び出しを認めることになる。

```fsharp
    let rec f () = f () // f 自身を呼ぶ

    let f () = f () // 上の f を呼ぶ
```

## その他

次のような考え方もある。

### ローカルの環境と名前空間を分けて考える

例えば次のようにモジュール functions の中に関数 f があるとき、f は「モジュール functions の内部」という名前空間と、ローカルの環境の両方にインポートされる。
非修飾名の f はローカル環境から関数を見つけ、修飾名の `functions::f` は名前空間から関数を見つける。

```rust
mod functions {
    pub fn f() {}

    fn g() {
        f(); // ローカルの環境から関数 f を見つける
    }
}

fn h() {
    functions::f(); // functions の名前空間から関数 f を見つける
}
```

言い換えると、関数 f の本体は名前空間や環境とは別のところにあって、それへのリンクが名前空間や環境に配置される、と考える。

ローカルの環境が影響するのはパス式の先頭と、ローカル環境が直接的に明示されたとき (`self::local_var` など) だけである点にも注意。うまく設計された言語では、ローカル環境に依存する名前の解決は構文的に行える。

### エイリアスをローカルのシンボルとみなす

use 文がエイリアスを導入するとき、このエイリアスの出現は指定されたシンボルの出現とみなすこともできるが、ここでは「エイリアス」という種類のシンボルが定義されているのだと考えることもできる。
use 文はエイリアスをローカルに定義するものだと考えておくと、モジュール内に他のモジュールのシンボルが直接出現することはないと考えることができる。
また、インポートの処理を遅延できる。

例えば `use functions::f;` としたとき、この f は (functions::f に定義された関数 f そのものではなく) このモジュールに f というエイリアスを新たに定義する。
f の出現はこのエイリアスの出現とみなす。
その後、エイリアス f から関数 functions::f へのリンクを張って、エイリアスの出現を関数の出現として処理する。

## 参考

- [Name lookup - cppreference.com](https://en.cppreference.com/w/cpp/language/lookup) (C++ の名前ルックアップ)
- [Name resolution - Guide to Rustc Development](https://rustc-dev-guide.rust-lang.org/name-resolution.html) (Rust コンパイラの名前解決に関する説明)
- [Three Architectures for a Responsive IDE](https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html) (IDE の性能について書かれた記事。言語の名前解決ルールが関係してくる)
